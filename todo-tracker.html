<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>To-Do Tracker</title>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --input-bg: #f5f5f5;
      --border-color: #cccccc;
      --accent-color: #4a90e2;
      --card-bg: #f9f9f9;
      --sidebar-bg: #f0f0f0;
      --sidebar-width: 250px;
      --sidebar-collapsed-width: 60px;
    }

    .dark-mode {
      --bg-color: #222222;
      --text-color: #f5f5f5;
      --input-bg: #333333;
      --border-color: #555555;
      --accent-color: #5a9aea;
      --card-bg: #2d2d2d;
      --sidebar-bg: #1a1a1a;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: all 0.3s ease;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar styles */
    .sidebar {
      width: var(--sidebar-width);
      background-color: var(--sidebar-bg);
      border-right: 1px solid var(--border-color);
      transition: width 0.3s ease;
      overflow-y: auto;
      padding: 20px 0;
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      z-index: 100;
    }

    .sidebar.collapsed {
      width: var(--sidebar-collapsed-width);
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .sidebar-title {
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--accent-color);
      margin: 0;
    }

    .toggle-sidebar {
      background: none;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      font-size: 1.2rem;
    }

    .topic-list {
      list-style: none;
      padding: 0;
      margin: 20px 0;
    }

    .topic-item {
      padding: 10px 20px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .topic-item:hover {
      background-color: rgba(0,0,0,0.05);
    }

    .topic-item.active {
      background-color: rgba(74, 144, 226, 0.1);
      border-left: 3px solid var(--accent-color);
    }

    .topic-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .topic-count {
      background-color: var(--accent-color);
      color: white;
      border-radius: 10px;
      padding: 2px 8px;
      font-size: 0.8rem;
    }

    .sidebar-actions {
      padding: 0 20px;
      margin-top: 20px;
    }

    .add-topic-btn {
      width: 100%;
      padding: 8px;
      background-color: var(--accent-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    /* Main content styles */
    .main-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      margin-left: var(--sidebar-width);
      transition: margin-left 0.3s ease;
    }

    .sidebar.collapsed + .main-content {
      margin-left: var(--sidebar-collapsed-width);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }

    h1 {
      color: var(--accent-color);
      margin: 0;
    }

    .controls {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    .sort-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sort-controls label {
      font-weight: 500;
      color: var(--text-color);
    }

    .sort-controls select {
      padding: 6px 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--input-bg);
      color: var(--text-color);
      font-size: 14px;
    }

    /* Task card styles */
    .task-card {
      background-color: var(--card-bg);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
      position: relative;
    }

    .task-card:hover {
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      transform: none; /* Remove the movement on hover */
    }

    .task-card {
      cursor: default;
    }

    .task-card.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }



    .task-title {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
    }

    .task-title h3 {
      margin: 0;
      color: var(--accent-color);
      display: flex;
      align-items: center;
    }

    .task-date {
      color: var(--text-color);
      opacity: 0.7;
    }

    /* Priority indicator */
    .priority {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 14px;
      margin-bottom: 15px;
      color: white;
    }

    .priority-high {
      background-color: #e74c3c;
    }

    .priority-medium {
      background-color: #f39c12;
    }

    .priority-low {
      background-color: #2ecc71;
    }

    /* Task form */
    .task-form {
      background-color: var(--card-bg);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .form-group input,
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--input-bg);
      color: var(--text-color);
    }

    /* Buttons */
    button {
      background-color: var(--accent-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    button:hover {
      opacity: 0.9;
    }

    .delete-btn {
      background-color: #e74c3c;
    }

    /* Checkbox styling */
    .task-checkbox {
      margin-right: 10px;
      transform: scale(1.5);
    }

    .completed-task {
      text-decoration: line-through;
      opacity: 0.7;
    }

    /* Dark mode toggle */
    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 5px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      z-index: 2;
    }

    input:checked + .slider {
      background-color: var(--accent-color);
    }

    input:checked + .slider:before {
      transform: translateX(30px);
    }

    .slider.round {
      border-radius: 34px;
    }

    .slider.round:before {
      border-radius: 50%;
    }

    .icon {
      font-size: 14px;
      z-index: 1;
    }

    /* Topic header styles */
    .topic-header {
      margin-top: 30px;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--accent-color);
      padding-bottom: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .topic-header h2 {
      color: var(--accent-color);
      margin: 0;
      font-size: 1.5rem;
    }

    .collapse-btn {
      background: none;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      font-size: 1.2rem;
      padding: 5px;
    }

    .topic-content {
      transition: max-height 0.3s ease;
      overflow: hidden;
    }

    .topic-content.collapsed {
      max-height: 0;
    }

    /* Dropzone styles */
    .dropzone {
      border: 2px dashed var(--border-color);
      border-radius: 8px;
      margin-bottom: 20px;
      padding: 20px;
      text-align: center;
      color: var(--text-color);
      opacity: 0.7;
      transition: all 0.2s;
    }

    .dropzone.active {
      border-color: var(--accent-color);
      background-color: rgba(74, 144, 226, 0.1);
    }

    /* Empty state */
    .no-tasks {
      text-align: center;
      padding: 40px 0;
      color: var(--text-color);
      opacity: 0.7;
    }

    /* Responsive styles */
    @media (max-width: 768px) {
      body {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        max-height: 200px;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
        position: fixed;
        top: 0;
        left: 0;
        height: auto;
        z-index: 100;
      }

      .sidebar.collapsed {
        max-height: 60px;
        width: 100%;
      }

      .main-content {
        margin-left: 0;
        margin-top: 200px;
      }

      .sidebar.collapsed + .main-content {
        margin-left: 0;
        margin-top: 60px;
      }

      .floating-add-btn {
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
    }



    /* Add CSS for context menus and drag-and-drop */
    .context-menu {
      position: absolute;
      background-color: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      min-width: 180px;
    }

    .context-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .context-menu-item:hover {
      background-color: rgba(74, 144, 226, 0.1);
    }

    .context-menu-separator {
      height: 1px;
      background-color: var(--border-color);
      margin: 4px 0;
    }

    .context-menu-submenu {
      position: relative;
    }

    .context-menu-submenu .submenu {
      display: none;
      position: absolute;
      left: 100%;
      top: 0;
      background-color: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      min-width: 150px;
    }

    .context-menu-submenu:hover .submenu {
      display: block;
    }

    .topic-item.drag-over {
      background-color: rgba(74, 144, 226, 0.2);
      border-left: 4px solid var(--accent-color);
    }

    .topic-header.drag-over {
      background-color: rgba(74, 144, 226, 0.1);
      border: 2px dashed var(--accent-color);
      border-radius: 4px;
    }

    .task-card.dragging {
      opacity: 0.5;
      cursor: grabbing;
      transform: rotate(2deg);
    }

    .drag-indicator {
      position: fixed;
      background-color: var(--accent-color);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }

    /* Task reordering styles */
    .task-drop-zone {
      height: 4px;
      margin: 2px 0;
      border-radius: 2px;
      transition: all 0.2s ease;
      opacity: 0;
    }

    .task-drop-zone.active {
      opacity: 1;
      height: 8px;
      background-color: var(--accent-color);
      margin: 8px 0;
    }

    .topic-content.reordering .task-drop-zone {
      opacity: 0.3;
      height: 6px;
      background-color: var(--border-color);
    }

    /* Floating Add Task Button */
    .floating-add-btn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: var(--accent-color);
      color: white;
      border: none;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floating-add-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }

    .floating-add-btn:active {
      transform: scale(0.95);
    }

    /* Hide the original Add Task button in header */
    .header #add-task-btn {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h2 class="sidebar-title">Topics</h2>
      <button class="toggle-sidebar" id="toggle-sidebar">◀</button>
    </div>

    <ul class="topic-list" id="topic-list">
      <li class="topic-item active" data-topic-id="all">
        <span class="topic-name">All Tasks</span>
        <span class="topic-count" id="all-count">0</span>
      </li>
      <li class="topic-item" data-topic-id="">
        <span class="topic-name">Uncategorized</span>
        <span class="topic-count" id="uncategorized-count">0</span>
      </li>
      <li class="topic-item" data-topic-id="completed">
        <span class="topic-name">Completed</span>
        <span class="topic-count" id="completed-count">0</span>
      </li>
      <!-- Topics will be populated here -->
    </ul>

    <div class="sidebar-actions">
      <button class="add-topic-btn" id="add-topic-btn">+ New Topic</button>
    </div>
  </div>

  <!-- Main content -->
  <div class="main-content">
    <div class="header">
      <h1>To-Do Tracker</h1>
      <div class="controls">
        <div class="sort-controls">
          <label for="sort-by">Sort by:</label>
          <select id="sort-by">
            <option value="none">Default</option>
            <option value="date-asc">Date (Oldest First)</option>
            <option value="date-desc">Date (Newest First)</option>
            <option value="priority-high">Priority (High to Low)</option>
            <option value="priority-low">Priority (Low to High)</option>
          </select>
        </div>
        <button id="add-task-btn">Add Task</button>
        <button id="clear-completed-btn">Clear Completed</button>
        <label class="switch">
          <input type="checkbox" id="theme-toggle">
          <span class="slider round">
            <i class="icon light">☀️</i>
            <i class="icon dark">🌙</i>
          </span>
        </label>
      </div>
    </div>

    <div id="task-form-container" style="display: none;">
      <div class="task-form">
        <div class="form-group">
          <label for="task-title">Task Title:</label>
          <input type="text" id="task-title" required>
        </div>
        <div class="form-group">
          <label for="task-description">Description:</label>
          <textarea id="task-description" rows="3"></textarea>
        </div>
        <div class="form-group">
          <label for="due-date">Due Date:</label>
          <input type="date" id="due-date">
        </div>
        <div class="form-group">
          <label for="priority">Priority:</label>
          <select id="priority">
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>
        </div>
        <div class="form-group">
          <label for="task-topic">Topic/Thread:</label>
          <select id="task-topic">
            <option value="">-- No Topic --</option>
            <!-- Topics will be populated dynamically -->
          </select>
        </div>
        <div class="form-actions">
          <button id="save-task-btn">Save Task</button>
          <button id="cancel-task-btn">Cancel</button>
        </div>
      </div>
    </div>

    <div id="tasks-container">
      <!-- Tasks will be populated here -->
      <div class="no-tasks" id="no-tasks-message">
        No tasks added yet. Create your first task!
      </div>
    </div>
  </div>

  <!-- Drag indicator -->
  <div id="drag-indicator" class="drag-indicator"></div>

  <!-- Floating Add Task Button -->
  <button id="floating-add-task-btn" class="floating-add-btn" title="Add Task">+</button>

  <script>
    // Global variables
    let currentTopicFilter = 'all';
    let currentSortMethod = 'none';
    let draggedTask = null;
    let draggedTaskTopicId = null;
    let isReordering = false;

    // Load topics from localStorage
    function loadTopics() {
      const topicSelect = document.getElementById('task-topic');
      const topicList = document.getElementById('topic-list');
      const topics = JSON.parse(localStorage.getItem('todoTopics') || '[]');
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');

      // Keep the first "No Topic" option in the form select
      topicSelect.innerHTML = '<option value="">-- No Topic --</option>';

      // Clear the topic list first
      topicList.innerHTML = '';

      // Add default items with proper event listeners
      const defaultTopics = [
        { id: 'all', name: 'All Tasks', count: tasks.length },
        { id: '', name: 'Uncategorized', count: tasks.filter(task => !task.topicId || task.topicId === '').length },
        { id: 'completed', name: 'Completed', count: tasks.filter(task => task.completed).length }
      ];

      // Add default topics to sidebar
      defaultTopics.forEach(topic => {
        const li = document.createElement('li');
        li.className = 'topic-item';
        li.dataset.topicId = topic.id;

        // Set active class if this is the current filter
        if (topic.id === currentTopicFilter) {
          li.classList.add('active');
        }

        li.innerHTML = `
          <span class="topic-name">${topic.name}</span>
          <span class="topic-count" id="${topic.id === '' ? 'uncategorized' : topic.id}-count">${topic.count}</span>
        `;

        // Add click event to filter tasks
        li.addEventListener('click', function() {
          // Remove active class from all topics
          document.querySelectorAll('.topic-item').forEach(item => {
            item.classList.remove('active');
          });

          // Add active class to clicked topic
          this.classList.add('active');

          // Set current topic filter
          currentTopicFilter = this.dataset.topicId;

          // Load tasks with new filter
          loadTasks();
        });

        // Add drag and drop events for sidebar topics
        li.addEventListener('dragover', function(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          this.classList.add('drag-over');
        });

        li.addEventListener('dragleave', function(e) {
          this.classList.remove('drag-over');
        });

        li.addEventListener('drop', function(e) {
          e.preventDefault();
          this.classList.remove('drag-over');

          if (draggedTask) {
            const success = moveTaskToTopic(draggedTask, this.dataset.topicId);
            if (!success) {
              alert('Cannot move completed tasks to regular topics or incomplete tasks to completed.');
            }
            draggedTask = null;
          }
        });

        topicList.appendChild(li);
      });

      // Add custom topics to select and sidebar
      topics.forEach(topic => {
        // Add to form select
        const option = document.createElement('option');
        option.value = topic.id;
        option.textContent = topic.name;
        topicSelect.appendChild(option);

        // Add to sidebar
        const li = document.createElement('li');
        li.className = 'topic-item';
        li.dataset.topicId = topic.id;

        // Set active class if this is the current filter
        if (topic.id === currentTopicFilter) {
          li.classList.add('active');
        }

        // Count tasks for this topic
        const topicTasks = tasks.filter(task => task.topicId === topic.id);

        li.innerHTML = `
          <span class="topic-name">${topic.name}</span>
          <span class="topic-count">${topicTasks.length}</span>
        `;

        // Add click event to filter tasks
        li.addEventListener('click', function() {
          // Remove active class from all topics
          document.querySelectorAll('.topic-item').forEach(item => {
            item.classList.remove('active');
          });

          // Add active class to clicked topic
          this.classList.add('active');

          // Set current topic filter
          currentTopicFilter = this.dataset.topicId;

          // Load tasks with new filter
          loadTasks();
        });

        // Add drag and drop events for custom topics
        li.addEventListener('dragover', function(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          this.classList.add('drag-over');
        });

        li.addEventListener('dragleave', function(e) {
          this.classList.remove('drag-over');
        });

        li.addEventListener('drop', function(e) {
          e.preventDefault();
          this.classList.remove('drag-over');

          if (draggedTask) {
            const success = moveTaskToTopic(draggedTask, this.dataset.topicId);
            if (!success) {
              alert('Cannot move completed tasks to regular topics or incomplete tasks to completed.');
            }
            draggedTask = null;
          }
        });

        topicList.appendChild(li);
      });
    }

    // Set active topic item in sidebar
    function setActiveTopicItem(topicId) {
      const topicItems = document.querySelectorAll('.topic-item');
      topicItems.forEach(item => {
        if (item.dataset.topicId === topicId) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
    }

    // Create new topic
    function createNewTopic() {
      const topicName = prompt('Enter new topic name:');
      if (!topicName || !topicName.trim()) return;

      // Get existing topics
      const topics = JSON.parse(localStorage.getItem('todoTopics') || '[]');

      // Create new topic
      const newTopic = {
        id: Date.now().toString(),
        name: topicName.trim()
      };

      // Add to topics array
      topics.push(newTopic);

      // Save to localStorage
      localStorage.setItem('todoTopics', JSON.stringify(topics));

      // Reload topics
      loadTopics();

      // Select the new topic in the form if it's open
      const topicSelect = document.getElementById('task-topic');
      if (document.getElementById('task-form-container').style.display === 'block') {
        topicSelect.value = newTopic.id;
      }
    }

    // Load tasks from localStorage
    function loadTasks() {
      const tasksContainer = document.getElementById('tasks-container');
      tasksContainer.innerHTML = '';

      // Get tasks from localStorage
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
      const topics = JSON.parse(localStorage.getItem('todoTopics') || '[]');

      // Show no tasks message if needed
      if (tasks.length === 0) {
        const noTasksDiv = document.createElement('div');
        noTasksDiv.className = 'no-tasks';
        noTasksDiv.textContent = 'No tasks added yet. Create your first task!';
        tasksContainer.appendChild(noTasksDiv);
        return;
      }

      // Filter tasks based on current topic filter
      let filteredTasks = [];
      if (currentTopicFilter === 'all') {
        filteredTasks = tasks;

        // Apply sorting if enabled
        if (currentSortMethod !== 'none') {
          // Filter out completed tasks, then sort and display in a single list with drop zones
          const incompleteTasks = filteredTasks.filter(task => !task.completed);
          const sortedTasks = sortTasks(incompleteTasks);

          sortedTasks.forEach((task, index) => {
            // Add drop zone before first task
            if (index === 0) {
              const dropZone = createDropZone(task.id, true);
              tasksContainer.appendChild(dropZone);
            }

            const taskCard = createTaskCard(task);
            tasksContainer.appendChild(taskCard);

            // Add drop zone after each task
            const dropZone = createDropZone(task.id, false);
            tasksContainer.appendChild(dropZone);
          });
        } else {
          // Group tasks by topic (original behavior when no sorting)
          const tasksByTopic = {};

          // Add "Uncategorized" group
          tasksByTopic[''] = filteredTasks.filter(task => !task.topicId || task.topicId === '');

          // Add tasks for each topic
          topics.forEach(topic => {
            tasksByTopic[topic.id] = filteredTasks.filter(task => task.topicId === topic.id);
          });

          // Add "Completed" group if there are completed tasks
          const completedTasks = filteredTasks.filter(task => task.completed);
          if (completedTasks.length > 0) {
            tasksByTopic['completed'] = completedTasks;
          }

          // Create topic sections
          Object.keys(tasksByTopic).forEach(topicId => {
            if (tasksByTopic[topicId].length === 0) return;

            // Get topic name
            let topicName = 'Uncategorized';
            if (topicId === 'completed') {
              topicName = 'Completed';
            } else if (topicId !== '') {
              const topic = topics.find(t => t.id === topicId);
              if (topic) topicName = topic.name;
            }

            // Create topic header
            const topicHeader = document.createElement('div');
            topicHeader.className = 'topic-header';
            topicHeader.dataset.topicId = topicId;
            topicHeader.innerHTML = `
              <h2>${topicName}</h2>
              <button class="collapse-btn">▼</button>
            `;

            // Add drag and drop events to topic header
            topicHeader.addEventListener('dragover', function(e) {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              this.classList.add('drag-over');
            });

            topicHeader.addEventListener('dragleave', function(e) {
              this.classList.remove('drag-over');
            });

            topicHeader.addEventListener('drop', function(e) {
              e.preventDefault();
              this.classList.remove('drag-over');

              if (draggedTask) {
                const success = moveTaskToTopic(draggedTask, this.dataset.topicId);
                if (!success) {
                  alert('Cannot move completed tasks to regular topics or incomplete tasks to completed.');
                }
                draggedTask = null;
              }
            });

            // Create topic content container
            const topicContent = document.createElement('div');
            topicContent.className = 'topic-content';
            topicContent.dataset.topicId = topicId;

            // Add tasks to topic content with drop zones for reordering
            tasksByTopic[topicId].forEach((task, index) => {
              // Add drop zone before first task
              if (index === 0) {
                const dropZone = createDropZone(task.id, true);
                topicContent.appendChild(dropZone);
              }

              const taskCard = createTaskCard(task);
              topicContent.appendChild(taskCard);

              // Add drop zone after each task
              const dropZone = createDropZone(task.id, false);
              topicContent.appendChild(dropZone);
            });

            // Add to container
            tasksContainer.appendChild(topicHeader);
            tasksContainer.appendChild(topicContent);

            // Add collapse functionality
            const collapseBtn = topicHeader.querySelector('.collapse-btn');
            collapseBtn.addEventListener('click', function() {
              topicContent.classList.toggle('collapsed');
              this.textContent = topicContent.classList.contains('collapsed') ? '▶' : '▼';
            });
          });
        }
      } else if (currentTopicFilter === 'completed') {
        // Show only completed tasks
        filteredTasks = tasks.filter(task => task.completed);

        // Apply sorting and add tasks to container with drop zones
        const sortedTasks = sortTasks(filteredTasks);
        sortedTasks.forEach((task, index) => {
          // Add drop zone before first task
          if (index === 0) {
            const dropZone = createDropZone(task.id, true);
            tasksContainer.appendChild(dropZone);
          }

          const taskCard = createTaskCard(task);
          tasksContainer.appendChild(taskCard);

          // Add drop zone after each task
          const dropZone = createDropZone(task.id, false);
          tasksContainer.appendChild(dropZone);
        });
      } else {
        // Filter by specific topic
        filteredTasks = tasks.filter(task => task.topicId === currentTopicFilter);

        // Apply sorting and add tasks to container with drop zones (exclude completed tasks when sorting)
        const tasksToSort = currentSortMethod !== 'none' ? filteredTasks.filter(task => !task.completed) : filteredTasks;
        const sortedTasks = sortTasks(tasksToSort);
        sortedTasks.forEach((task, index) => {
          // Add drop zone before first task
          if (index === 0) {
            const dropZone = createDropZone(task.id, true);
            tasksContainer.appendChild(dropZone);
          }

          const taskCard = createTaskCard(task);
          tasksContainer.appendChild(taskCard);

          // Add drop zone after each task
          const dropZone = createDropZone(task.id, false);
          tasksContainer.appendChild(dropZone);
        });
      }

      // Show no tasks message if needed after filtering
      if (filteredTasks.length === 0) {
        const noTasksDiv = document.createElement('div');
        noTasksDiv.className = 'no-tasks';
        noTasksDiv.textContent = 'No tasks found for this filter.';
        tasksContainer.appendChild(noTasksDiv);
      }
    }

    // Create a task card element
    function createTaskCard(task) {
      const card = document.createElement('div');
      card.className = 'task-card';
      card.dataset.id = task.id;
      card.draggable = true; // Make card draggable

      // Priority class mapping
      const priorityClass = `priority-${task.priority || 'medium'}`;

      // Format due date (fix timezone issue by parsing as local date)
      let dueDate = 'No due date';
      if (task.dueDate) {
        // Parse the date string as local date to avoid timezone issues
        const dateParts = task.dueDate.split('-');
        const localDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
        dueDate = localDate.toLocaleDateString();
      }

      // Create the HTML structure
      card.innerHTML = `
        <div class="task-title">
          <h3 class="${task.completed ? 'completed-task' : ''}">
            <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''}>
            ${task.title}
          </h3>
          <span class="task-date">${dueDate}</span>
        </div>
        <div class="priority ${priorityClass}">${task.priority ? task.priority.charAt(0).toUpperCase() + task.priority.slice(1) : 'Medium'}</div>
        ${task.description ? `
        <div class="task-description">
          <p>${task.description}</p>
        </div>` : ''}
      `;

      // Add checkbox event
      const checkbox = card.querySelector('.task-checkbox');
      checkbox.addEventListener('change', function(e) {
        e.stopPropagation();
        toggleTaskCompletion(task.id);
      });

      // Add double-click event for editing
      card.addEventListener('dblclick', function(e) {
        e.preventDefault();
        editTask(task.id);
      });

      // Add right-click context menu for tasks
      card.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        showTaskContextMenu(e, task.id);
      });

      // Add drag events
      card.addEventListener('dragstart', function(e) {
        draggedTask = task.id;
        draggedTaskTopicId = task.topicId;
        this.classList.add('dragging');
        e.dataTransfer.setData('text/plain', task.id);
        e.dataTransfer.effectAllowed = 'move';

        // Check if we're in a context where reordering is possible
        const topicContent = this.closest('.topic-content');
        if (topicContent) {
          isReordering = true;
          topicContent.classList.add('reordering');
        }

        // Minimal drag feedback - no excessive tooltips
      });

      card.addEventListener('dragend', function() {
        this.classList.remove('dragging');
        hideDragIndicator();

        // Clean up any remaining drag-over states
        document.querySelectorAll('.drag-over').forEach(el => {
          el.classList.remove('drag-over');
        });

        // Clean up reordering states
        document.querySelectorAll('.reordering').forEach(el => {
          el.classList.remove('reordering');
        });

        document.querySelectorAll('.task-drop-zone.active').forEach(el => {
          el.classList.remove('active');
        });

        draggedTask = null;
        draggedTaskTopicId = null;
        isReordering = false;
      });

      return card;
    }

    // Show task context menu
    function showTaskContextMenu(e, taskId) {
      // Remove any existing context menu
      hideContextMenu();

      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
      const task = tasks.find(t => t.id == taskId);
      if (!task) return;

      const contextMenu = document.createElement('div');
      contextMenu.className = 'context-menu';
      contextMenu.id = 'task-context-menu';

      // Position the menu
      contextMenu.style.left = e.pageX + 'px';
      contextMenu.style.top = e.pageY + 'px';

      // Create menu items
      const menuItems = [
        {
          text: '✏️ Edit',
          action: () => editTask(taskId)
        },
        {
          text: task.completed ? '↩️ Mark Incomplete' : '✅ Mark Complete',
          action: () => toggleTaskCompletion(taskId)
        },
        {
          text: '🗑️ Delete',
          action: () => deleteTask(taskId)
        },
        {
          text: '🏷️ Change Priority',
          submenu: [
            {
              text: '🔴 High',
              action: () => changeTaskPriority(taskId, 'high')
            },
            {
              text: '🟡 Medium',
              action: () => changeTaskPriority(taskId, 'medium')
            },
            {
              text: '🟢 Low',
              action: () => changeTaskPriority(taskId, 'low')
            }
          ]
        }
      ];

      // Build menu HTML
      menuItems.forEach(item => {
        if (item.submenu) {
          const submenuContainer = document.createElement('div');
          submenuContainer.className = 'context-menu-submenu';

          const mainItem = document.createElement('div');
          mainItem.className = 'context-menu-item';
          mainItem.textContent = item.text + ' ▶';

          const submenu = document.createElement('div');
          submenu.className = 'submenu';

          item.submenu.forEach(subItem => {
            const subMenuItem = document.createElement('div');
            subMenuItem.className = 'context-menu-item';
            subMenuItem.textContent = subItem.text;
            subMenuItem.addEventListener('click', () => {
              subItem.action();
              hideContextMenu();
            });
            submenu.appendChild(subMenuItem);
          });

          submenuContainer.appendChild(mainItem);
          submenuContainer.appendChild(submenu);
          contextMenu.appendChild(submenuContainer);
        } else {
          const menuItem = document.createElement('div');
          menuItem.className = 'context-menu-item';
          menuItem.textContent = item.text;
          menuItem.addEventListener('click', () => {
            item.action();
            hideContextMenu();
          });
          contextMenu.appendChild(menuItem);
        }
      });

      document.body.appendChild(contextMenu);

      // Adjust position if menu goes off screen
      const rect = contextMenu.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        contextMenu.style.left = (e.pageX - rect.width) + 'px';
      }
      if (rect.bottom > window.innerHeight) {
        contextMenu.style.top = (e.pageY - rect.height) + 'px';
      }
    }

    // Hide context menu
    function hideContextMenu() {
      const existingMenu = document.getElementById('task-context-menu');
      if (existingMenu) {
        existingMenu.remove();
      }
    }

    // Change task priority
    function changeTaskPriority(taskId, newPriority) {
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
      const taskIndex = tasks.findIndex(t => t.id == taskId);

      if (taskIndex !== -1) {
        tasks[taskIndex].priority = newPriority;
        localStorage.setItem('todoTasks', JSON.stringify(tasks));
        loadTasks();
      }
    }

    // Move task to different topic
    function moveTaskToTopic(taskId, newTopicId) {
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
      const taskIndex = tasks.findIndex(t => t.id == taskId);

      if (taskIndex !== -1) {
        // Don't allow moving completed tasks to non-completed topics
        if (tasks[taskIndex].completed && newTopicId !== 'completed') {
          return false;
        }

        // Don't allow moving incomplete tasks to completed topic
        if (!tasks[taskIndex].completed && newTopicId === 'completed') {
          return false;
        }

        // Update the task's topic
        tasks[taskIndex].topicId = newTopicId === 'completed' ? tasks[taskIndex].topicId : newTopicId;

        localStorage.setItem('todoTasks', JSON.stringify(tasks));
        loadTopics();
        loadTasks();
        return true;
      }
      return false;
    }

    // Show drag indicator
    function showDragIndicator(e, text) {
      const indicator = document.getElementById('drag-indicator');
      indicator.textContent = text;
      indicator.style.display = 'block';
      indicator.style.left = (e.clientX + 10) + 'px';
      indicator.style.top = (e.clientY - 10) + 'px';
    }

    // Hide drag indicator
    function hideDragIndicator() {
      const indicator = document.getElementById('drag-indicator');
      indicator.style.display = 'none';
    }

    // Reorder tasks within a topic
    function reorderTasksInTopic(draggedTaskId, targetTaskId, insertBefore = true) {
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
      const draggedTaskIndex = tasks.findIndex(t => t.id == draggedTaskId);
      const targetTaskIndex = tasks.findIndex(t => t.id == targetTaskId);

      if (draggedTaskIndex === -1 || targetTaskIndex === -1) {
        console.log('Task not found:', draggedTaskId, targetTaskId);
        return false;
      }

      // Don't reorder if dropping on the same position
      if (draggedTaskIndex === targetTaskIndex ||
          (insertBefore && draggedTaskIndex === targetTaskIndex - 1) ||
          (!insertBefore && draggedTaskIndex === targetTaskIndex + 1)) {
        return false;
      }

      // Remove the dragged task from its current position
      const draggedTask = tasks.splice(draggedTaskIndex, 1)[0];

      // Recalculate target index after removal
      let newTargetIndex = tasks.findIndex(t => t.id == targetTaskId);

      // Adjust insertion point
      const insertIndex = insertBefore ? newTargetIndex : newTargetIndex + 1;

      // Insert the task at the new position
      tasks.splice(insertIndex, 0, draggedTask);

      localStorage.setItem('todoTasks', JSON.stringify(tasks));
      loadTopics();
      loadTasks();
      return true;
    }

    // Create drop zone element
    function createDropZone(targetTaskId, insertBefore = true) {
      const dropZone = document.createElement('div');
      dropZone.className = 'task-drop-zone';
      dropZone.dataset.targetTaskId = targetTaskId;
      dropZone.dataset.insertBefore = insertBefore;

      dropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.add('active');
        // Remove excessive tooltips - just show visual feedback
      });

      dropZone.addEventListener('dragleave', function(e) {
        this.classList.remove('active');
      });

      dropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('active');
        hideDragIndicator();

        if (draggedTask && isReordering) {
          console.log('Attempting reorder:', draggedTask, 'target:', this.dataset.targetTaskId, 'before:', this.dataset.insertBefore);

          // Check if both tasks are in the same topic
          const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
          const draggedTaskObj = tasks.find(t => t.id == draggedTask);
          const targetTaskObj = tasks.find(t => t.id == this.dataset.targetTaskId);

          if (draggedTaskObj && targetTaskObj && draggedTaskObj.topicId === targetTaskObj.topicId) {
            const success = reorderTasksInTopic(draggedTask, this.dataset.targetTaskId, this.dataset.insertBefore === 'true');
            console.log('Reorder result:', success);
          } else {
            console.log('Tasks not in same topic, skipping reorder');
          }
        }
      });

      return dropZone;
    }

    // Sort tasks based on current sort method
    function sortTasks(tasks) {
      if (currentSortMethod === 'none') {
        return tasks;
      }

      const sortedTasks = [...tasks];

      switch (currentSortMethod) {
        case 'date-asc':
          return sortedTasks.sort((a, b) => {
            const dateA = a.dueDate ? new Date(a.dueDate) : new Date('9999-12-31');
            const dateB = b.dueDate ? new Date(b.dueDate) : new Date('9999-12-31');
            return dateA - dateB;
          });

        case 'date-desc':
          return sortedTasks.sort((a, b) => {
            const dateA = a.dueDate ? new Date(a.dueDate) : new Date('1900-01-01');
            const dateB = b.dueDate ? new Date(b.dueDate) : new Date('1900-01-01');
            return dateB - dateA;
          });

        case 'priority-high':
          return sortedTasks.sort((a, b) => {
            const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
            const priorityA = priorityOrder[a.priority || 'medium'];
            const priorityB = priorityOrder[b.priority || 'medium'];
            return priorityB - priorityA;
          });

        case 'priority-low':
          return sortedTasks.sort((a, b) => {
            const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
            const priorityA = priorityOrder[a.priority || 'medium'];
            const priorityB = priorityOrder[b.priority || 'medium'];
            return priorityA - priorityB;
          });

        default:
          return sortedTasks;
      }
    }

    // Toggle sidebar collapse
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const mainContent = document.querySelector('.main-content');

      sidebar.classList.toggle('collapsed');

      const toggleBtn = document.getElementById('toggle-sidebar');
      toggleBtn.textContent = sidebar.classList.contains('collapsed') ? '▶' : '◀';

      // Update main content margin for fixed sidebar
      if (window.innerWidth > 768) {
        if (sidebar.classList.contains('collapsed')) {
          mainContent.style.marginLeft = 'var(--sidebar-collapsed-width)';
        } else {
          mainContent.style.marginLeft = 'var(--sidebar-width)';
        }
      }
    }

    // Toggle task completion status
    function toggleTaskCompletion(id) {
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
      const taskIndex = tasks.findIndex(t => t.id == id);

      if (taskIndex !== -1) {
        // Toggle completion status
        tasks[taskIndex].completed = !tasks[taskIndex].completed;

        // If task is completed, store original topic and move to completed
        if (tasks[taskIndex].completed) {
          tasks[taskIndex].originalTopicId = tasks[taskIndex].topicId;
          tasks[taskIndex].topicId = 'completed';
        } else {
          // If unchecked, restore original topic
          tasks[taskIndex].topicId = tasks[taskIndex].originalTopicId || '';
          delete tasks[taskIndex].originalTopicId;
        }

        localStorage.setItem('todoTasks', JSON.stringify(tasks));
        loadTopics();
        loadTasks();
      }
    }

    // Edit task
    function editTask(id) {
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
      const task = tasks.find(t => t.id == id);

      if (task) {
        // Show form and populate with task data
        document.getElementById('task-form-container').style.display = 'block';
        document.getElementById('task-title').value = task.title;
        document.getElementById('task-description').value = task.description || '';
        document.getElementById('due-date').value = task.dueDate || '';
        document.getElementById('priority').value = task.priority || 'medium';
        document.getElementById('task-topic').value = task.topicId || '';

        // Update save button to handle edit
        const saveBtn = document.getElementById('save-task-btn');
        saveBtn.dataset.editId = id;

        // Ensure the form is visible
        window.scrollTo({
          top: document.getElementById('task-form-container').offsetTop - 20,
          behavior: 'smooth'
        });
      }
    }

    // Delete task
    function deleteTask(id) {
      if (confirm('Are you sure you want to delete this task?')) {
        const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
        const updatedTasks = tasks.filter(task => task.id != id);
        localStorage.setItem('todoTasks', JSON.stringify(updatedTasks));
        loadTopics();
        loadTasks();
      }
    }

    // Clear completed tasks
    function clearCompletedTasks() {
      if (confirm('Are you sure you want to remove all completed tasks?')) {
        const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');
        const updatedTasks = tasks.filter(task => !task.completed);
        localStorage.setItem('todoTasks', JSON.stringify(updatedTasks));
        loadTopics();
        loadTasks();
      }
    }

    // Save task (new or edited)
    function saveTask() {
      const titleInput = document.getElementById('task-title');
      const descriptionInput = document.getElementById('task-description');
      const dueDateInput = document.getElementById('due-date');
      const priorityInput = document.getElementById('priority');
      const topicInput = document.getElementById('task-topic');
      const saveBtn = document.getElementById('save-task-btn');

      // Validate title
      if (!titleInput.value.trim()) {
        alert('Please enter a task title');
        return;
      }

      // Get tasks from localStorage
      const tasks = JSON.parse(localStorage.getItem('todoTasks') || '[]');

      // Check if editing or creating new
      const editId = saveBtn.dataset.editId;

      if (editId) {
        // Edit existing task
        const taskIndex = tasks.findIndex(t => t.id == editId);
        if (taskIndex !== -1) {
          tasks[taskIndex] = {
            ...tasks[taskIndex],
            title: titleInput.value.trim(),
            description: descriptionInput.value.trim(),
            dueDate: dueDateInput.value,
            priority: priorityInput.value,
            topicId: topicInput.value
          };
        }
        // Clear edit ID
        delete saveBtn.dataset.editId;
      } else {
        // Create new task
        const newTask = {
          id: Date.now(),
          title: titleInput.value.trim(),
          description: descriptionInput.value.trim(),
          dueDate: dueDateInput.value,
          priority: priorityInput.value,
          topicId: topicInput.value,
          completed: false
        };
        tasks.push(newTask);
      }

      // Save to localStorage
      localStorage.setItem('todoTasks', JSON.stringify(tasks));

      // Reset form and hide
      resetTaskForm();

      // Reload topics and tasks
      loadTopics();
      loadTasks();
    }

    // Reset task form
    function resetTaskForm() {
      document.getElementById('task-title').value = '';
      document.getElementById('task-description').value = '';
      document.getElementById('due-date').value = '';
      document.getElementById('priority').value = 'medium';
      document.getElementById('task-topic').value = '';
      document.getElementById('task-form-container').style.display = 'none';

      // Clear any edit ID
      const saveBtn = document.getElementById('save-task-btn');
      delete saveBtn.dataset.editId;
    }

    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Load topics
      loadTopics();

      // Load tasks
      loadTasks();

      // Add task button (original - now hidden)
      document.getElementById('add-task-btn').addEventListener('click', function() {
        document.getElementById('task-form-container').style.display = 'block';

        // Default to current topic if one is selected (but not 'all' or 'completed')
        const topicSelect = document.getElementById('task-topic');
        if (currentTopicFilter && currentTopicFilter !== 'all' && currentTopicFilter !== 'completed') {
          topicSelect.value = currentTopicFilter;
        }
      });

      // Floating Add task button
      document.getElementById('floating-add-task-btn').addEventListener('click', function() {
        document.getElementById('task-form-container').style.display = 'block';

        // Default to current topic if one is selected (but not 'all' or 'completed')
        const topicSelect = document.getElementById('task-topic');
        if (currentTopicFilter && currentTopicFilter !== 'all' && currentTopicFilter !== 'completed') {
          topicSelect.value = currentTopicFilter;
        }

        // Scroll to the form
        document.getElementById('task-form-container').scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      });

      // New topic button
      document.getElementById('add-topic-btn').addEventListener('click', createNewTopic);

      // Save task button
      document.getElementById('save-task-btn').addEventListener('click', saveTask);

      // Cancel task button
      document.getElementById('cancel-task-btn').addEventListener('click', resetTaskForm);

      // Clear completed button
      document.getElementById('clear-completed-btn').addEventListener('click', clearCompletedTasks);

      // Toggle sidebar button
      document.getElementById('toggle-sidebar').addEventListener('click', toggleSidebar);

      // Sort dropdown
      document.getElementById('sort-by').addEventListener('change', function() {
        currentSortMethod = this.value;
        localStorage.setItem('todoSortMethod', currentSortMethod);
        loadTasks();
      });

      // Dark mode toggle
      const toggleButton = document.getElementById('theme-toggle');
      toggleButton.addEventListener('change', function() {
        document.body.classList.toggle('dark-mode');
        localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
      });

      // Apply saved dark mode preference
      if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        toggleButton.checked = true;
      }

      // Apply saved sort method preference
      const savedSortMethod = localStorage.getItem('todoSortMethod');
      if (savedSortMethod) {
        currentSortMethod = savedSortMethod;
        document.getElementById('sort-by').value = savedSortMethod;
      }

      // Handle clicks on the document to hide context menu
      document.addEventListener('click', function(e) {
        // Hide context menu when clicking outside of it
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
      });
    });
  </script>
</body>
</html>